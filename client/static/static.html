<!DOCTYPE html><html lang="pt-br"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="../public/style/language.css"><link rel="stylesheet" href="../public/style/style.css"><link rel="icon" href="../public/assets/images/logo-blue.svg"><title>Go</title><script src="script.js"></script></head><body><section class="slide front"><div class="banner"><div class="logo"></div><div class="block"><h1>Linguagens de Programação</h1><ul class="inline-list"><li>Alan Lima</li> <li>Juan Pablo</li> <li>Luan Filipe</li> <li>Mateus Silva</li> <li>Vitor Mozer</li></ul></div></div><div class="gopher"></div></section><section class="slide headed"><header><div class="logo"></div><h1>Introdução</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Introdução</h1><p>A linguagem Go, também connhecida como GoLang, é uma linguagem de programação compilada e coletada a lixo, desenvolvida pela Google em 2007, concebida por uma equipe de renomados engenheiros (Robert Griesemer, Rob Pike e Ken Thompson) e lançada oficialmente em 2009. Com sua primeira versão estável lançada em 2012.</p><p>Motivações para o desenvolvimento:</p><ul class="bullet-list"><li>Produtividade</li><li>Concorrência Nativa</li><li>Desempenho</li><li>Backend</li></ul></div><figure class="gopher-coding"><img src="../public/assets/images/gopher_coding.gif" alt="Gopher Coding"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>História</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>História</h1><p>Frustados com a complexidade e compilação lenta de linguagens como C++ para sistemas do Google, os engenheiros decidiram criar uma linguagem que combinasse o melhor dos dois mundos: a eficiência de C/C++ e a simplicidade de Python.</p><p>Após dois anos de desenvolvimento, Go foi oficialmente lançado em 2009 como um projeto de código aberto. Sua simplicidade, performance e o seu poderoso sistema de concorrência rapidamente conquistaram a comunidade de desenvolvedores e também grandes empresas como Netflix, Uber e Dropbox que adotaram Go para construir sistemas escaláveis e de alto desempenho.</p></div><figure class="creators"><img class="soft" src="../public/assets/images/creators.jpeg" alt="Go creators"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Tecnologias</h1><span class="page-number">0</span></header><article class="general"><code class="scrollable">package main&NewLine;&NewLine;import (&NewLine;&Tab;"encoding/json"&NewLine;&Tab;"fmt"&NewLine;&Tab;"io"&NewLine;&Tab;"log"&NewLine;&Tab;"net/http"&NewLine;&Tab;"os"&NewLine;&Tab;"os/exec"&NewLine;&Tab;"regexp"&NewLine;&Tab;"strconv"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;type _RequestBody struct {&NewLine;&Tab;Code string   `json:"code"`&NewLine;&Tab;Args []string `json:"args"`&NewLine;}&NewLine;&NewLine;type _ResponseBody struct {&NewLine;&Tab;Output   []byte `json:"output"`&NewLine;&Tab;ExitCode int    `json:"exitcode"`&NewLine;}&NewLine;&NewLine;func _LaunchServer(addr string) {&NewLine;&Tab;mux := http.NewServeMux()&NewLine;&NewLine;&Tab;mux.HandleFunc("POST /gorun", _GoRunHandler)&NewLine;&NewLine;&Tab;_FileServe(mux, "/", "./client/public")&NewLine;&Tab;_FileServe(mux, "/assets/code/server/", "./server")&NewLine;&NewLine;&Tab;log.Printf("Server running at \033[38;2;234;154;12m%s\033[m", addr)&NewLine;&NewLine;&Tab;server := &http.Server{&NewLine;&Tab;&Tab;Addr:  addr,&NewLine;&Tab;&Tab;Handler:   mux,&NewLine;&Tab;&Tab;ReadHeaderTimeout: 5 * time.Second,&NewLine;&Tab;}&NewLine;&NewLine;&Tab;err := server.ListenAndServe()&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;log.Fatal(err)&NewLine;&Tab;}&NewLine;}&NewLine;&NewLine;func _FileServe(mux *http.ServeMux, route, filename string) {&NewLine;&Tab;handler := http.StripPrefix(route, http.FileServer(http.Dir(filename)))&NewLine;&NewLine;&Tab;mux.HandleFunc("GET "+route, func(w http.ResponseWriter, r *http.Request) {&NewLine;&Tab;&Tab;log.Println("request from:", r.URL.Path)&NewLine;&Tab;&Tab;handler.ServeHTTP(w, r)&NewLine;&Tab;})&NewLine;}&NewLine;&NewLine;var PortPattern = regexp.MustCompile(`^:\d+$`)&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;port := ":8080"&NewLine;&NewLine;&Tab;if len(os.Args) &gt; 1 {&NewLine;&Tab;&Tab;port = os.Args[1]&NewLine;&NewLine;&Tab;&Tab;if !PortPattern.MatchString(port) {&NewLine;&Tab;&Tab;&Tab;fmt.Println("bad port, try \":&lt;number&gt;\"")&NewLine;&Tab;&Tab;&Tab;return&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;num, _ := strconv.Atoi(port[1:])&NewLine;&Tab;&Tab;if num &lt; 0 && 0xFFFF &lt; num {&NewLine;&Tab;&Tab;&Tab;fmt.Println("too high, try a 16-bit unsigned integer")&NewLine;&Tab;&Tab;&Tab;return&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;_LaunchServer(port)&NewLine;}&NewLine;&NewLine;func _GoRunHandler(w http.ResponseWriter, r *http.Request) {&NewLine;&NewLine;&Tab;log.Println("request from:", r.Host)&NewLine;&NewLine;&Tab;body, err := io.ReadAll(r.Body)&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to read request", http.StatusBadRequest)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&Tab;defer r.Body.Close()&NewLine;&NewLine;&Tab;var c _RequestBody&NewLine;&Tab;err = json.Unmarshal(body, &c)&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to parse the body", http.StatusBadRequest)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;tmpFile, err := os.CreateTemp("", "code-*.go")&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to create temp file", http.StatusInternalServerError)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&Tab;defer os.Remove(tmpFile.Name())&NewLine;&NewLine;&Tab;_, err = tmpFile.Write([]byte(c.Code))&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to write file", http.StatusInternalServerError)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&Tab;tmpFile.Close()&NewLine;&NewLine;&Tab;args := append([]string{"run", tmpFile.Name()}, c.Args...)&NewLine;&Tab;cmd := exec.Command("go", args...)&NewLine;&NewLine;&Tab;cmdOutput, _ := cmd.CombinedOutput()&NewLine;&NewLine;&Tab;response := _ResponseBody{&NewLine;&Tab;&Tab;Output:   cmdOutput,&NewLine;&Tab;&Tab;ExitCode: cmd.ProcessState.ExitCode(),&NewLine;&Tab;}&NewLine;&NewLine;&Tab;j, err := json.Marshal(response)&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to parse output", http.StatusInternalServerError)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;w.Header().Set("Content-Type", "application/json")&NewLine;&Tab;w.WriteHeader(http.StatusOK)&NewLine;&Tab;w.Write(j)&NewLine;}&NewLine;</code><div class="text"><h1>Tecnologias</h1><p>A linguagem Go é amplamente utilizada em diversas áreas da tecnologia, com sua combinação única de simplicidade, performance e um modelo de concorrência excepcional, se estabeleceu como uma ferramenta poderosa para uma variedade de aplicações no mundo da tecnologia moderna.</p><p>Abaixo estão algumas das tecnologias e ferramentas mais notáveis que utilizam Go:</p><ul class="bullet-list"><li>Desenvolvimento Web e APIs</li><li>Acesso a Banco de Dados</li><li>Infraestrutura e Nuvem (Cloud-Native)</li></ul></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Utilização</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Utilização</h1><p>A linguagem Go, se estabeleceu como uma ferramenta poderosa para uma variedade de aplicações no mundo da tecnologia moderna. Alguns softwares e ferramentas que utilizam o Go:</p><ul class="bullet-list"><li>Uber: Suporte a lógica de roteamento de corridas, cálculo de preços e telemetria em tempo real</li><li>Dropbox: Serviços de sincronização e transferência de arquivos, otimizados com Go para performance de I/O</li><li>SoundCloud: Ingestão de uploads de áudio e orquestração de transcodificação em massa</li><li>Docker: Plataforma de conteinerização que empacota aplicações e suas dependências em “containers” leves e portáteis</li><li>Hugo: Gerador de sites estáticos ultrarrápido</li><li>Caddy: Servidor web avançado e de código aberto, criado em Go, que oferece HTTPS automático por padrão</li></ul></div><figure class="software"><img class="soft" src="../public/assets/images/gophers.png" alt="Gophers Playing"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Especificação</h1><span class="page-number">0</span></header><article class="general"><code>package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"math/rand"&NewLine;&Tab;"os"&NewLine;&Tab;"strconv"&NewLine;&Tab;"sync"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;func SingleThreaded(arr []int) (sum int) {&NewLine;&Tab;for _, v := range arr {&NewLine;&Tab;&Tab;sum += v&NewLine;&Tab;}&NewLine;&NewLine;&Tab;return&NewLine;}&NewLine;&NewLine;func _PartialSum(arr []int, resch chan int, wg *sync.WaitGroup) {&NewLine;&Tab;defer wg.Done()&NewLine;&NewLine;&Tab;var sum int&NewLine;&Tab;for _, v := range arr {&NewLine;&Tab;&Tab;sum += v&NewLine;&Tab;}&NewLine;&Tab;resch &lt;- sum&NewLine;}&NewLine;&NewLine;func MultiThreaded(arr []int) int {&NewLine;&NewLine;&Tab;const chunk_size = 1024&NewLine;&Tab;num_workers := len(arr) / chunk_size&NewLine;&NewLine;&Tab;resch := make(chan int, num_workers+1)&NewLine;&Tab;var wg sync.WaitGroup&NewLine;&NewLine;&Tab;for i := range num_workers {&NewLine;&Tab;&Tab;start := i * chunk_size&NewLine;&Tab;&Tab;end := start + chunk_size&NewLine;&NewLine;&Tab;&Tab;chunk := arr[start:end]&NewLine;&NewLine;&Tab;&Tab;wg.Add(1)&NewLine;&Tab;&Tab;go _PartialSum(chunk, resch, &wg)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;{&NewLine;&Tab;&Tab;left_over := arr[chunk_size*num_workers:]&NewLine;&NewLine;&Tab;&Tab;if len(left_over) &gt;= 0 {&NewLine;&Tab;&Tab;&Tab;wg.Add(1)&NewLine;&Tab;&Tab;&Tab;go _PartialSum(left_over, resch, &wg)&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;wg.Wait()&NewLine;&Tab;close(resch)&NewLine;&NewLine;&Tab;var total int&NewLine;&Tab;for part := range resch {&NewLine;&Tab;&Tab;total += part&NewLine;&Tab;}&NewLine;&NewLine;&Tab;return total&NewLine;}&NewLine;&NewLine;func BenchMark(fn func([]int) int, arr []int) (int, time.Duration) {&NewLine;&Tab;start := time.Now()&NewLine;&NewLine;&Tab;sum := fn(arr)&NewLine;&NewLine;&Tab;return sum, time.Since(start)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;if len(os.Args) &lt; 2 {&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;size, err := strconv.Atoi(os.Args[1])&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;fmt.Fprintln(os.Stderr, err)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if size &lt;= 0 {&NewLine;&Tab;&Tab;fmt.Fprintln(os.Stderr, "the informed number must be &gt;0")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;arr := make([]int, size)&NewLine;&Tab;var sum int&NewLine;&NewLine;&Tab;for i := range size {&NewLine;&Tab;&Tab;// rand in [-size, size&#41;&NewLine;&Tab;&Tab;arr[i] = rand.Intn(2*size) - size&NewLine;&Tab;&Tab;sum += arr[i]&NewLine;&Tab;}&NewLine;&NewLine;&Tab;ssum, stt := BenchMark(SingleThreaded, arr)&NewLine;&Tab;msum, mtt := BenchMark(MultiThreaded, arr)&NewLine;&NewLine;&Tab;if ssum != sum {&NewLine;&Tab;&Tab;fmt.Printf("the single-threaded sum, %d, is different from %d\n", ssum, sum)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if msum != sum {&NewLine;&Tab;&Tab;fmt.Printf("the multi-threaded sum, %d, is different from %d\n", msum, sum)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Singlethreaded: %d&mu;s\n",&NewLine;&Tab;&Tab;stt.Microseconds())&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Multithreaded:  %d&mu;s\n",&NewLine;&Tab;&Tab;mtt.Microseconds())&NewLine;}</code><div class="text"><h1>Especificação</h1><p>O linguagem Go, mais precisamente, sua gramática, é definida completamente em<var><a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a></var>. Enquanto a documentação está disponível em <var><a href="https://go.dev/doc/">https://go.dev/doc/</a></var>.</p><p>Go segue uma filosofia minimalista, tendo, por exemplo, apenas 25 palavras-chaves: <var>break</var><var>default</var> <var>func</var> <var>interface</var> <var>select</var> <var>case</var><var>defer</var> <var>go</var> <var>map</var> <var>struct</var> <var>chan</var> <var>else</var><var>goto</var> <var>package</var> <var>switch</var> <var>const</var> <var>fallthrough</var><var>if</var> <var>range</var> <var>type</var> <var>continue</var> <var>for</var> <var>import</var><var>return</var> <var>var</var>.</p><p>O Go tem os tipos primitivos: <var>bool</var> <var>byte</var> <var>rune</var> <var>int</var><var>int8</var> <var>int16</var> <var>int32</var> <var>int64</var> <var>uint</var> <var>uint8</var><var>uint16</var> <var>uint32</var> <var>uint64</var> <var>float32</var> <var>float64</var><var>complex64</var> <var>complex128</var> <var>string</var> e <var>error</var>.</p></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Paradigma</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Paradigma</h1><p>Go é uma linguagem de programação multiparadigma, o que significa que suporta diferentes estilos de programação. Os principais paradigmas suportados pelo Go são:</p><ul class="bullet-list"><li>Programação Imperativa: o estilo mais comum, onde o programador descreve passo a passo como o programa deve ser executado</li><li>Programação Funcional: suporte a funções de primeira classe, permitindo passar funções como argumentos e retornar funções de outras</li><li>Programação Orientada a Objetos: embora Go não tenha classes, ele suporta tipos e métodos, permitindo encapsulamento, e, de certa forma, herança</li><li>Programação Concorrente: com goroutines e canais, Go facilita a escrita de programas que podem executar várias tarefas ao mesmo tempo</li></ul></div><code>package main&NewLine;&NewLine;import "fmt"&NewLine;&NewLine;type Pessoa struct {&NewLine;&Tab;nome string&NewLine;&Tab;cpf  string&NewLine;}&NewLine;&NewLine;func (p *Pessoa) Cumprimenta() func() {&NewLine;&Tab;return func() {&NewLine;&Tab;&Tab;fmt.Printf("Olá, %s!\n", p.nome)&NewLine;&Tab;}&NewLine;}&NewLine;&NewLine;type Cliente struct {&NewLine;&Tab;código int&NewLine;&Tab;Pessoa&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&Tab;c := Cliente{&NewLine;&Tab;&Tab;1,&NewLine;&Tab;&Tab;Pessoa{"Mateus", "987.654.321-00"},&NewLine;&Tab;}&NewLine;&NewLine;&Tab;c.Cumprimenta()()&NewLine;}&NewLine;</code></article></section><section class="slide headed"><header><div class="logo"></div><h1>Ambientes de Desenvolvimento</h1><span class="page-number">0</span></header><article class="image"><figure class="gopher"><img src="../public/assets/images/gopher.png" alt="Go's Gopher"></figure><div class="text"><h1>Ambientes de Desenvolvimento</h1><p>Para programar em Go, você pode usar qualquer editor de texto, mas existem algumas ferramentas que facilitam muito a vida dos desenvolvedores.</p><p>Essas ferramentas ajudam a escrever código mais rápido, encontrar erros e entender melhor o que está acontecendo no programa.</p><ul class="bullet-list"><li>Visual Studio Code: Um editor de código muito popular com suporte a Go</li><li>GoLand: Um IDE específico para Go, com muitas funcionalidades avançadas</li><li>Vim/Emacs: Editores de texto que também têm suporte a Go</li><li>Go Playground: Um site onde você pode escrever e executar código Go diretamente no navegador</li></ul></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Ambientes de Desenvolvimento</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Ambientes de Desenvolvimento</h1><p>Os comandos e estruturas fundamentais que formam a base para construir qualquer aplicação em Go, desde a linha de comando até sistemas complexos que interagem com dependências na nuvem:</p><ul class="bullet-list"><li><var>go run</var>: Compila e executa um ou mais arquivos de código-fonte Go</li><li><var>go build</var>: Compila os pacotes e suas dependências, gerando um arquivo executável</li><li><var>go get</var>: Baixa e instala pacotes de repositórios remotos, como o GitHub</li><li><var>go fmt</var>: Formata o código Go de acordo com as convenções de estilo da linguagem</li><li><var>go mod</var>: Gerencia dependências e módulos em projetos Go</li></ul></div><figure class="gopher"><img src="../public/assets/images/gopher.png" alt="Go's Gopher"></figure></article></section><section class="slide headed full-code"><header><div class="logo"></div><h1>Exemplos de Programas</h1><span class="page-number">0</span></header><code>package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"os"&NewLine;&Tab;"strconv"&NewLine;)&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;if len(os.Args) &lt; 2 {&NewLine;&Tab;&Tab;fmt.Println("You must inform a rule")&NewLine;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;var rule int&NewLine;&Tab;var err error&NewLine;&NewLine;&Tab;rule, err = strconv.Atoi(os.Args[1])&NewLine;&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;if os.Args[1] == "help" {&NewLine;&Tab;&Tab;&Tab;fmt.Println(os.Args[0], "&lt;rule&gt;", "[&lt;width&gt;]")&NewLine;&Tab;&Tab;&Tab;return&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;fmt.Println("The rule must be a number")&NewLine;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if rule &lt; 0 || 255 &lt; rule {&NewLine;&Tab;&Tab;fmt.Println("You must inform a rule between 0 and 255")&NewLine;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;width := 52&NewLine;&NewLine;&Tab;if len(os.Args) &gt; 2 {&NewLine;&NewLine;&Tab;&Tab;if os.Args[2] == "max" {&NewLine;&Tab;&Tab;&Tab;width = 238&NewLine;&Tab;&Tab;} else {&NewLine;&Tab;&Tab;&Tab;width, err = strconv.Atoi(os.Args[2])&NewLine;&NewLine;&Tab;&Tab;&Tab;if err != nil {&NewLine;&Tab;&Tab;&Tab;&Tab;fmt.Println("The width must be a number")&NewLine;&Tab;&Tab;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;&Tab;if width &lt;= 0 {&NewLine;&Tab;&Tab;&Tab;&Tab;fmt.Println("The width must be a positive number")&NewLine;&Tab;&Tab;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;&Tab;&Tab;}&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;fmt.Printf("Rendering rule %d\n", rule)&NewLine;&NewLine;&Tab;generation := [2][]int8{&NewLine;&Tab;&Tab;make([]int8, width),&NewLine;&Tab;&Tab;make([]int8, width),&NewLine;&Tab;}&NewLine;&NewLine;&Tab;generation[0][(width-1)/2] = 1&NewLine;&NewLine;&Tab;for y := range ((width + 3) / 2) & ^1 {&NewLine;&Tab;&Tab;top := generation[y&1][width-1]&lt;&lt;1 | generation[y&1][0]&NewLine;&NewLine;&Tab;&Tab;for x := range width - 1 {&NewLine;&Tab;&Tab;&Tab;top = top&0b011&lt;&lt;1 | generation[y&1][x+1]&NewLine;&NewLine;&Tab;&Tab;&Tab;if (rule & (1 &lt;&lt; top)) != 0 {&NewLine;&Tab;&Tab;&Tab;&Tab;generation[^y&1][x] = 1&NewLine;&Tab;&Tab;&Tab;} else {&NewLine;&Tab;&Tab;&Tab;&Tab;generation[^y&1][x] = 0&NewLine;&Tab;&Tab;&Tab;}&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;top = top&0b011&lt;&lt;1 | generation[y&1][0]&NewLine;&NewLine;&Tab;&Tab;if (rule & (1 &lt;&lt; top)) != 0 {&NewLine;&Tab;&Tab;&Tab;generation[^y&1][width-1] = 1&NewLine;&Tab;&Tab;} else {&NewLine;&Tab;&Tab;&Tab;generation[^y&1][width-1] = 0&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;if y&1 == 0 {&NewLine;&Tab;&Tab;&Tab;for x := range width {&NewLine;&Tab;&Tab;&Tab;&Tab;switch generation[0][x]&lt;&lt;1 | generation[1][x] {&NewLine;&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b00:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u0020")&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b01:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u2584")&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b10:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u2580")&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b11:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u2588")&NewLine;&Tab;&Tab;&Tab;&Tab;}&NewLine;&Tab;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;&Tab;fmt.Println()&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;}&NewLine;</code></section><section class="slide headed playground"><header><div class="logo"></div><h1>Exemplos de Programas</h1><span class="page-number">0</span></header><article><code class="input" spellcheck="false">package main&NewLine;&NewLine;import "fmt"&NewLine;&NewLine;func main() {&NewLine;&Tab;fmt.Println("Hello, World!")&NewLine;}</code><div class="run"><input class="args" type="text"><input class="submit" type="button" value="Run"></div><code class="output"></code></article></section><section class="slide headed"><header><div class="logo"></div><h1>Coletor de Lixo</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Coletor de Lixo</h1><p>O garbage collector (GC) em Go é responsável por gerenciar automaticamente a memória. Ele identifica e libera objetos que não são mais utilizados pelo programa, evitando vazamentos de memória.</p></div><figure class="gc"><img class="soft" src="../public/assets/images/gc.gif" alt="Coletor de Lixo"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Concorrência</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Concorrência em Go</h1><p>Concorrência é quando o programa consegue realizar várias tarefas ao mesmo tempo. Imagine um restaurante com vários garçons atendendo clientes ao mesmo tempo, isso é concorrência!</p><p>Em Go, usamos algo chamado goroutine para isso. Cada goroutine é como um garçom: ela faz um trabalho separado sem atrapalhar os outros.</p><p>Para os garçons (goroutines) se comunicarem entre si, usamos canais. Um canal é como um tubo por onde um manda mensagem para o outro.</p><p>O legal é que o Go cuida disso tudo automaticamente, sem que a gente precise se preocupar com detalhes complicados.</p><p>A ideia principal do Go é: "Em vez de brigar por acesso à memória, as partes do programa conversam entre si de forma organizada."</p></div><code>package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;// Simula um garçom chamando números da fila&NewLine;func chamarFila(nome string, ch chan string) {&NewLine;&NewLine;&Tab;for i := range 3 {&NewLine;&Tab;&Tab;ch &lt;- fmt.Sprintf(&NewLine;&Tab;&Tab;&Tab;"%s chamando número %d", nome, i+1)&NewLine;&NewLine;&Tab;&Tab;// Espera 0.1 seg&NewLine;&Tab;&Tab;time.Sleep(100 * time.Millisecond)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;close(ch)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;// Cria um canal pra enviar mensagens em string&NewLine;&Tab;canal := make(chan string)&NewLine;&NewLine;&Tab;// Inicia a função chamarFila em paralelo&NewLine;&Tab;go chamarFila("Alan  ", canal)&NewLine;&Tab;go chamarFila("Juan  ", canal)&NewLine;&Tab;go chamarFila("Luan  ", canal)&NewLine;&Tab;go chamarFila("Mateus", canal)&NewLine;&Tab;go chamarFila("Vitor ", canal)&NewLine;&NewLine;&Tab;// Recebe e imprime as mensagens enviadas&NewLine;&Tab;for mensagem := range canal {&NewLine;&Tab;&Tab;fmt.Println(mensagem)&NewLine;&Tab;}&NewLine;}&NewLine;</code></article></section><section class="slide headed playground"><header><div class="logo"></div><h1>Concorrência</h1><span class="page-number">0</span></header><article><div class="run"><input class="args" type="text"><input class="submit" type="button" value="Run"></div><code class="input" spellcheck="false">package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;// Simula um garçom chamando números da fila&NewLine;func chamarFila(nome string, ch chan string) {&NewLine;&NewLine;&Tab;for i := range 3 {&NewLine;&Tab;&Tab;ch &lt;- fmt.Sprintf(&NewLine;&Tab;&Tab;&Tab;"%s chamando número %d", nome, i+1)&NewLine;&NewLine;&Tab;&Tab;// Espera 0.1 seg&NewLine;&Tab;&Tab;time.Sleep(100 * time.Millisecond)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;close(ch)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;// Cria um canal pra enviar mensagens em string&NewLine;&Tab;canal := make(chan string)&NewLine;&NewLine;&Tab;// Inicia a função chamarFila em paralelo&NewLine;&Tab;go chamarFila("Alan  ", canal)&NewLine;&Tab;go chamarFila("Juan  ", canal)&NewLine;&Tab;go chamarFila("Luan  ", canal)&NewLine;&Tab;go chamarFila("Mateus", canal)&NewLine;&Tab;go chamarFila("Vitor ", canal)&NewLine;&NewLine;&Tab;// Recebe e imprime as mensagens enviadas&NewLine;&Tab;for mensagem := range canal {&NewLine;&Tab;&Tab;fmt.Println(mensagem)&NewLine;&Tab;}&NewLine;}&NewLine;</code><code class="output"></code></article></section><section class="slide headed playground"><header><div class="logo"></div><h1>Concorrência</h1><span class="page-number">0</span></header><article><div class="run"><input class="args" type="text"><input class="submit" type="button" value="Run"></div><code class="input" spellcheck="false">package main&NewLine;&NewLine;import (&NewLine;&Tab;"cmp"&NewLine;&Tab;"fmt"&NewLine;&Tab;"math/rand"&NewLine;&Tab;"os"&NewLine;&Tab;"strconv"&NewLine;&Tab;"sync"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;const LenghtThreshold = 32&NewLine;&NewLine;func SingleThreadedQuickSort(arr []int) {&NewLine;&NewLine;&Tab;if len(arr) &lt;= LenghtThreshold {&NewLine;&Tab;&Tab;InsertionSort(arr)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;pivot := _Partition(arr)&NewLine;&NewLine;&Tab;SingleThreadedQuickSort(arr[:pivot])&NewLine;&Tab;SingleThreadedQuickSort(arr[pivot+1:])&NewLine;}&NewLine;&NewLine;func MultiThreadedQuickSort(arr []int) {&NewLine;&NewLine;&Tab;if len(arr) &lt;= LenghtThreshold {&NewLine;&Tab;&Tab;InsertionSort(arr)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;var wg sync.WaitGroup&NewLine;&NewLine;&Tab;wg.Add(1)&NewLine;&Tab;go _SyncMultiThreadedQuickSort(arr, &wg)&NewLine;&NewLine;&Tab;wg.Wait()&NewLine;}&NewLine;&NewLine;func _SyncMultiThreadedQuickSort(arr []int, wg *sync.WaitGroup) {&NewLine;&NewLine;&Tab;defer wg.Done()&NewLine;&NewLine;&Tab;if len(arr) &lt;= LenghtThreshold {&NewLine;&Tab;&Tab;InsertionSort(arr)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;pivot := _Partition(arr)&NewLine;&NewLine;&Tab;wg.Add(2)&NewLine;&Tab;go _SyncMultiThreadedQuickSort(arr[:pivot], wg)&NewLine;&Tab;go _SyncMultiThreadedQuickSort(arr[pivot+1:], wg)&NewLine;}&NewLine;&NewLine;func _Partition(arr []int) int {&NewLine;&NewLine;&Tab;pivot := arr[0]&NewLine;&Tab;i := 1&NewLine;&NewLine;&Tab;for j := 1; j &lt; len(arr); j++ {&NewLine;&Tab;&Tab;if arr[j] &lt;= pivot {&NewLine;&Tab;&Tab;&Tab;arr[i], arr[j] = arr[j], arr[i]&NewLine;&Tab;&Tab;&Tab;i++&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;arr[0], arr[i-1] = arr[i-1], arr[0]&NewLine;&Tab;return i - 1&NewLine;}&NewLine;&NewLine;func BenchMark(fn func([]int), arr []int) time.Duration {&NewLine;&Tab;start := time.Now()&NewLine;&NewLine;&Tab;fn(arr)&NewLine;&NewLine;&Tab;return time.Since(start)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;if len(os.Args) &lt; 2 {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"you must inform a number")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;size, err := strconv.Atoi(os.Args[1])&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;fmt.Println(err)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if size &lt;= 0 {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"the informed number must be >0")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;var sarr, marr []int&NewLine;&NewLine;&Tab;{&NewLine;&Tab;&Tab;arr := make([]int, size)&NewLine;&NewLine;&Tab;&Tab;for i := range arr {&NewLine;&Tab;&Tab;&Tab;arr[i] = i + 1&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;for i := range len(arr) {&NewLine;&Tab;&Tab;&Tab;s := rand.Intn(size)&NewLine;&Tab;&Tab;&Tab;arr[i], arr[s] = arr[s], arr[i]&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;sarr = make([]int, len(arr))&NewLine;&Tab;&Tab;copy(sarr, arr)&NewLine;&Tab;&Tab;marr = arr&NewLine;&Tab;}&NewLine;&NewLine;&Tab;mtt := BenchMark(MultiThreadedQuickSort, marr)&NewLine;&Tab;stt := BenchMark(SingleThreadedQuickSort, sarr)&NewLine;&NewLine;&Tab;if !_VerifySortion(sarr) {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"the singletheaded array wasn't sorted correctly")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if !_VerifySortion(marr) {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"the multitheaded array wasn't sorted correctly")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Singlethreaded: %dμs\n",&NewLine;&Tab;&Tab;stt.Microseconds())&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Multithreaded: %dμs\n",&NewLine;&Tab;&Tab;mtt.Microseconds())&NewLine;}&NewLine;&NewLine;func _VerifySortion[T cmp.Ordered](arr []T) bool {&NewLine;&NewLine;&Tab;for i := 1; i &lt; len(arr); i++ {&NewLine;&Tab;&Tab;if arr[i-1] > arr[i] {&NewLine;&Tab;&Tab;&Tab;return false&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;return true&NewLine;}&NewLine;&NewLine;func InsertionSort(arr []int) {&NewLine;&Tab;for i := 1; i &lt; len(arr); i++ {&NewLine;&NewLine;&Tab;&Tab;for tmp, j := arr[i], i; ; j-- {&NewLine;&NewLine;&Tab;&Tab;&Tab;if j &lt;= 0 || arr[j-1] &lt;= tmp {&NewLine;&Tab;&Tab;&Tab;&Tab;arr[j] = tmp&NewLine;&Tab;&Tab;&Tab;&Tab;break&NewLine;&Tab;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;&Tab;arr[j] = arr[j-1]&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;}</code><code class="output"></code></article></section><section class="slide headed"><header><div class="logo"></div><h1>Vantagens e Desvantagens</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Vantagens</h1><ul class="bullet-list"><li>Desempenho: compilação rápida</li><li>Simplicidade: sintaxe clara e fácil de aprender</li><li>Concorrência Nativa: suporte robusto para concorrência</li><li>Portabilidade: código em Go pode ser executado em diferentes arquiteturas e sistemas operacionais</li><li>Curva de Aprendizado: fácil de aprender para iniciantes</li></ul></div><div class="text"><h1>Desvantagens</h1><ul class="bullet-list"><li>Falta de Recursos Avançados: não possui recursos como herança, operador ternário e sobrecarga de funcões</li><li>Bibliotecas Limitadas: ecossistema ainda em crescimento</li><li>Coletor de lixo: torna o gerenciamento de memória menos eficiente</li><li>Curva de Aprendizado: Pode ser difícil para iniciantes devido à concorrência e gerenciamento de memória</li></ul></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Conclusão</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Conclusão</h1><p>Ao adentrarmos nossa jornada pela linguagem Go, fica claro que nao estamos falando apenas de mais uma ferramenta no vasto universo da programação. Go nasceu de uma necessidade real, de uma frustração de seus criadores com as ferramentas existentes, e sua solução foi prática: simplicidade aliada á performance.</p><p>Go nos ensina uma lição valiosa, na complexidade de software modernos, as vezes a solução mais sofisticada é uma mais simples.</p></div><code>package main&NewLine;&NewLine;import "fmt"&NewLine;&NewLine;func main() {&NewLine;&Tab;fmt.Println("Bye, World! 👋😁")&NewLine;}&NewLine;</code></article></section><section class="slide final">Fim da apresentação</section><footer><progress class="progress"></progress></footer></body></html>