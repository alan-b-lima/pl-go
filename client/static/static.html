<!DOCTYPE html><html lang="pt-br"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="../public/style/language.css"><link rel="stylesheet" href="../public/style/style.css"><link rel="icon" href="../public/assets/images/logo-blue.svg"><title>Go</title><script src="script.js"></script></head><body><section class="slide front"><div class="banner"><div class="logo"></div><div class="block"><h1>Linguagens de Programa√ß√£o</h1><ul class="inline-list"><li>Alan Lima</li> <li>Juan Pablo</li> <li>Luan Filipe</li> <li>Mateus Silva</li> <li>Vitor Mozer</li></ul></div></div><div class="gopher"></div></section><section class="slide headed"><header><div class="logo"></div><h1>Introdu√ß√£o</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Introdu√ß√£o</h1><p>A linguagem Go, tamb√©m connhecida como GoLang, √© uma linguagem de programa√ß√£o compilada e coletada a lixo, desenvolvida pela Google em 2007, concebida por uma equipe de renomados engenheiros (Robert Griesemer, Rob Pike e Ken Thompson) e lan√ßada oficialmente em 2009. Com sua primeira vers√£o est√°vel lan√ßada em 2012.</p><p>Motiva√ß√µes para o desenvolvimento:</p><ul class="bullet-list"><li>Produtividade</li><li>Concorr√™ncia Nativa</li><li>Desempenho</li><li>Backend</li></ul></div><figure class="gopher-coding"><img src="../public/assets/images/gopher_coding.gif" alt="Gopher Coding"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Hist√≥ria</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Hist√≥ria</h1><p>Frustados com a complexidade e compila√ß√£o lenta de linguagens como C++ para sistemas do Google, os engenheiros decidiram criar uma linguagem que combinasse o melhor dos dois mundos: a efici√™ncia de C/C++ e a simplicidade de Python.</p><p>Ap√≥s dois anos de desenvolvimento, Go foi oficialmente lan√ßado em 2009 como um projeto de c√≥digo aberto. Sua simplicidade, performance e o seu poderoso sistema de concorr√™ncia rapidamente conquistaram a comunidade de desenvolvedores e tamb√©m grandes empresas como Netflix, Uber e Dropbox que adotaram Go para construir sistemas escal√°veis e de alto desempenho.</p></div><figure class="creators"><img class="soft" src="../public/assets/images/creators.jpeg" alt="Go creators"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Tecnologias</h1><span class="page-number">0</span></header><article class="general"><code class="scrollable">package main&NewLine;&NewLine;import (&NewLine;&Tab;"encoding/json"&NewLine;&Tab;"fmt"&NewLine;&Tab;"io"&NewLine;&Tab;"log"&NewLine;&Tab;"net/http"&NewLine;&Tab;"os"&NewLine;&Tab;"os/exec"&NewLine;&Tab;"regexp"&NewLine;&Tab;"strconv"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;type _RequestBody struct {&NewLine;&Tab;Code string   `json:"code"`&NewLine;&Tab;Args []string `json:"args"`&NewLine;}&NewLine;&NewLine;type _ResponseBody struct {&NewLine;&Tab;Output   []byte `json:"output"`&NewLine;&Tab;ExitCode int    `json:"exitcode"`&NewLine;}&NewLine;&NewLine;func _LaunchServer(addr string) {&NewLine;&Tab;mux := http.NewServeMux()&NewLine;&NewLine;&Tab;mux.HandleFunc("POST /gorun", _GoRunHandler)&NewLine;&NewLine;&Tab;_FileServe(mux, "/", "./client/public")&NewLine;&Tab;_FileServe(mux, "/assets/code/server/", "./server")&NewLine;&NewLine;&Tab;log.Printf("Server running at \033[38;2;234;154;12m%s\033[m", addr)&NewLine;&NewLine;&Tab;server := &http.Server{&NewLine;&Tab;&Tab;Addr:  addr,&NewLine;&Tab;&Tab;Handler:   mux,&NewLine;&Tab;&Tab;ReadHeaderTimeout: 5 * time.Second,&NewLine;&Tab;}&NewLine;&NewLine;&Tab;err := server.ListenAndServe()&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;log.Fatal(err)&NewLine;&Tab;}&NewLine;}&NewLine;&NewLine;func _FileServe(mux *http.ServeMux, route, filename string) {&NewLine;&Tab;handler := http.StripPrefix(route, http.FileServer(http.Dir(filename)))&NewLine;&NewLine;&Tab;mux.HandleFunc("GET "+route, func(w http.ResponseWriter, r *http.Request) {&NewLine;&Tab;&Tab;log.Println("request from:", r.URL.Path)&NewLine;&Tab;&Tab;handler.ServeHTTP(w, r)&NewLine;&Tab;})&NewLine;}&NewLine;&NewLine;var PortPattern = regexp.MustCompile(`^:\d+$`)&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;port := ":8080"&NewLine;&NewLine;&Tab;if len(os.Args) &gt; 1 {&NewLine;&Tab;&Tab;port = os.Args[1]&NewLine;&NewLine;&Tab;&Tab;if !PortPattern.MatchString(port) {&NewLine;&Tab;&Tab;&Tab;fmt.Println("bad port, try \":&lt;number&gt;\"")&NewLine;&Tab;&Tab;&Tab;return&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;num, _ := strconv.Atoi(port[1:])&NewLine;&Tab;&Tab;if num &lt; 0 && 0xFFFF &lt; num {&NewLine;&Tab;&Tab;&Tab;fmt.Println("too high, try a 16-bit unsigned integer")&NewLine;&Tab;&Tab;&Tab;return&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;_LaunchServer(port)&NewLine;}&NewLine;&NewLine;func _GoRunHandler(w http.ResponseWriter, r *http.Request) {&NewLine;&NewLine;&Tab;log.Println("request from:", r.Host)&NewLine;&NewLine;&Tab;body, err := io.ReadAll(r.Body)&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to read request", http.StatusBadRequest)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&Tab;defer r.Body.Close()&NewLine;&NewLine;&Tab;var c _RequestBody&NewLine;&Tab;err = json.Unmarshal(body, &c)&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to parse the body", http.StatusBadRequest)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;tmpFile, err := os.CreateTemp("", "code-*.go")&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to create temp file", http.StatusInternalServerError)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&Tab;defer os.Remove(tmpFile.Name())&NewLine;&NewLine;&Tab;_, err = tmpFile.Write([]byte(c.Code))&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to write file", http.StatusInternalServerError)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&Tab;tmpFile.Close()&NewLine;&NewLine;&Tab;args := append([]string{"run", tmpFile.Name()}, c.Args...)&NewLine;&Tab;cmd := exec.Command("go", args...)&NewLine;&NewLine;&Tab;cmdOutput, _ := cmd.CombinedOutput()&NewLine;&NewLine;&Tab;response := _ResponseBody{&NewLine;&Tab;&Tab;Output:   cmdOutput,&NewLine;&Tab;&Tab;ExitCode: cmd.ProcessState.ExitCode(),&NewLine;&Tab;}&NewLine;&NewLine;&Tab;j, err := json.Marshal(response)&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;http.Error(w, "failed to parse output", http.StatusInternalServerError)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;w.Header().Set("Content-Type", "application/json")&NewLine;&Tab;w.WriteHeader(http.StatusOK)&NewLine;&Tab;w.Write(j)&NewLine;}&NewLine;</code><div class="text"><h1>Tecnologias</h1><p>A linguagem Go √© amplamente utilizada em diversas √°reas da tecnologia, com sua combina√ß√£o √∫nica de simplicidade, performance e um modelo de concorr√™ncia excepcional, se estabeleceu como uma ferramenta poderosa para uma variedade de aplica√ß√µes no mundo da tecnologia moderna.</p><p>Abaixo est√£o algumas das tecnologias e ferramentas mais not√°veis que utilizam Go:</p><ul class="bullet-list"><li>Desenvolvimento Web e APIs</li><li>Acesso a Banco de Dados</li><li>Infraestrutura e Nuvem (Cloud-Native)</li></ul></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Utiliza√ß√£o</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Utiliza√ß√£o</h1><p>A linguagem Go, se estabeleceu como uma ferramenta poderosa para uma variedade de aplica√ß√µes no mundo da tecnologia moderna. Alguns softwares e ferramentas que utilizam o Go:</p><ul class="bullet-list"><li>Uber: Suporte a l√≥gica de roteamento de corridas, c√°lculo de pre√ßos e telemetria em tempo real</li><li>Dropbox: Servi√ßos de sincroniza√ß√£o e transfer√™ncia de arquivos, otimizados com Go para performance de I/O</li><li>SoundCloud: Ingest√£o de uploads de √°udio e orquestra√ß√£o de transcodifica√ß√£o em massa</li><li>Docker: Plataforma de conteineriza√ß√£o que empacota aplica√ß√µes e suas depend√™ncias em ‚Äúcontainers‚Äù leves e port√°teis</li><li>Hugo: Gerador de sites est√°ticos ultrarr√°pido</li><li>Caddy: Servidor web avan√ßado e de c√≥digo aberto, criado em Go, que oferece HTTPS autom√°tico por padr√£o</li></ul></div><figure class="software"><img class="soft" src="../public/assets/images/gophers.png" alt="Gophers Playing"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Especifica√ß√£o</h1><span class="page-number">0</span></header><article class="general"><code>package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"math/rand"&NewLine;&Tab;"os"&NewLine;&Tab;"strconv"&NewLine;&Tab;"sync"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;func SingleThreaded(arr []int) (sum int) {&NewLine;&Tab;for _, v := range arr {&NewLine;&Tab;&Tab;sum += v&NewLine;&Tab;}&NewLine;&NewLine;&Tab;return&NewLine;}&NewLine;&NewLine;func _PartialSum(arr []int, resch chan int, wg *sync.WaitGroup) {&NewLine;&Tab;defer wg.Done()&NewLine;&NewLine;&Tab;var sum int&NewLine;&Tab;for _, v := range arr {&NewLine;&Tab;&Tab;sum += v&NewLine;&Tab;}&NewLine;&Tab;resch &lt;- sum&NewLine;}&NewLine;&NewLine;func MultiThreaded(arr []int) int {&NewLine;&NewLine;&Tab;const chunk_size = 1024&NewLine;&Tab;num_workers := len(arr) / chunk_size&NewLine;&NewLine;&Tab;resch := make(chan int, num_workers+1)&NewLine;&Tab;var wg sync.WaitGroup&NewLine;&NewLine;&Tab;for i := range num_workers {&NewLine;&Tab;&Tab;start := i * chunk_size&NewLine;&Tab;&Tab;end := start + chunk_size&NewLine;&NewLine;&Tab;&Tab;chunk := arr[start:end]&NewLine;&NewLine;&Tab;&Tab;wg.Add(1)&NewLine;&Tab;&Tab;go _PartialSum(chunk, resch, &wg)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;{&NewLine;&Tab;&Tab;left_over := arr[chunk_size*num_workers:]&NewLine;&NewLine;&Tab;&Tab;if len(left_over) &gt;= 0 {&NewLine;&Tab;&Tab;&Tab;wg.Add(1)&NewLine;&Tab;&Tab;&Tab;go _PartialSum(left_over, resch, &wg)&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;wg.Wait()&NewLine;&Tab;close(resch)&NewLine;&NewLine;&Tab;var total int&NewLine;&Tab;for part := range resch {&NewLine;&Tab;&Tab;total += part&NewLine;&Tab;}&NewLine;&NewLine;&Tab;return total&NewLine;}&NewLine;&NewLine;func BenchMark(fn func([]int) int, arr []int) (int, time.Duration) {&NewLine;&Tab;start := time.Now()&NewLine;&NewLine;&Tab;sum := fn(arr)&NewLine;&NewLine;&Tab;return sum, time.Since(start)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;if len(os.Args) &lt; 2 {&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;size, err := strconv.Atoi(os.Args[1])&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;fmt.Fprintln(os.Stderr, err)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if size &lt;= 0 {&NewLine;&Tab;&Tab;fmt.Fprintln(os.Stderr, "the informed number must be &gt;0")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;arr := make([]int, size)&NewLine;&Tab;var sum int&NewLine;&NewLine;&Tab;for i := range size {&NewLine;&Tab;&Tab;// rand in [-size, size&#41;&NewLine;&Tab;&Tab;arr[i] = rand.Intn(2*size) - size&NewLine;&Tab;&Tab;sum += arr[i]&NewLine;&Tab;}&NewLine;&NewLine;&Tab;ssum, stt := BenchMark(SingleThreaded, arr)&NewLine;&Tab;msum, mtt := BenchMark(MultiThreaded, arr)&NewLine;&NewLine;&Tab;if ssum != sum {&NewLine;&Tab;&Tab;fmt.Printf("the single-threaded sum, %d, is different from %d\n", ssum, sum)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if msum != sum {&NewLine;&Tab;&Tab;fmt.Printf("the multi-threaded sum, %d, is different from %d\n", msum, sum)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Singlethreaded: %d&mu;s\n",&NewLine;&Tab;&Tab;stt.Microseconds())&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Multithreaded:  %d&mu;s\n",&NewLine;&Tab;&Tab;mtt.Microseconds())&NewLine;}</code><div class="text"><h1>Especifica√ß√£o</h1><p>O linguagem Go, mais precisamente, sua gram√°tica, √© definida completamente em<var><a href="https://go.dev/ref/spec">https://go.dev/ref/spec</a></var>. Enquanto a documenta√ß√£o est√° dispon√≠vel em <var><a href="https://go.dev/doc/">https://go.dev/doc/</a></var>.</p><p>Go segue uma filosofia minimalista, tendo, por exemplo, apenas 25 palavras-chaves: <var>break</var><var>default</var> <var>func</var> <var>interface</var> <var>select</var> <var>case</var><var>defer</var> <var>go</var> <var>map</var> <var>struct</var> <var>chan</var> <var>else</var><var>goto</var> <var>package</var> <var>switch</var> <var>const</var> <var>fallthrough</var><var>if</var> <var>range</var> <var>type</var> <var>continue</var> <var>for</var> <var>import</var><var>return</var> <var>var</var>.</p><p>O Go tem os tipos primitivos: <var>bool</var> <var>byte</var> <var>rune</var> <var>int</var><var>int8</var> <var>int16</var> <var>int32</var> <var>int64</var> <var>uint</var> <var>uint8</var><var>uint16</var> <var>uint32</var> <var>uint64</var> <var>float32</var> <var>float64</var><var>complex64</var> <var>complex128</var> <var>string</var> e <var>error</var>.</p></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Paradigma</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Paradigma</h1><p>Go √© uma linguagem de programa√ß√£o multiparadigma, o que significa que suporta diferentes estilos de programa√ß√£o. Os principais paradigmas suportados pelo Go s√£o:</p><ul class="bullet-list"><li>Programa√ß√£o Imperativa: o estilo mais comum, onde o programador descreve passo a passo como o programa deve ser executado</li><li>Programa√ß√£o Funcional: suporte a fun√ß√µes de primeira classe, permitindo passar fun√ß√µes como argumentos e retornar fun√ß√µes de outras</li><li>Programa√ß√£o Orientada a Objetos: embora Go n√£o tenha classes, ele suporta tipos e m√©todos, permitindo encapsulamento, e, de certa forma, heran√ßa</li><li>Programa√ß√£o Concorrente: com goroutines e canais, Go facilita a escrita de programas que podem executar v√°rias tarefas ao mesmo tempo</li></ul></div><code>package main&NewLine;&NewLine;import "fmt"&NewLine;&NewLine;type Pessoa struct {&NewLine;&Tab;nome string&NewLine;&Tab;cpf  string&NewLine;}&NewLine;&NewLine;func (p *Pessoa) Cumprimenta() func() {&NewLine;&Tab;return func() {&NewLine;&Tab;&Tab;fmt.Printf("Ol√°, %s!\n", p.nome)&NewLine;&Tab;}&NewLine;}&NewLine;&NewLine;type Cliente struct {&NewLine;&Tab;c√≥digo int&NewLine;&Tab;Pessoa&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&Tab;c := Cliente{&NewLine;&Tab;&Tab;1,&NewLine;&Tab;&Tab;Pessoa{"Mateus", "987.654.321-00"},&NewLine;&Tab;}&NewLine;&NewLine;&Tab;c.Cumprimenta()()&NewLine;}&NewLine;</code></article></section><section class="slide headed"><header><div class="logo"></div><h1>Ambientes de Desenvolvimento</h1><span class="page-number">0</span></header><article class="image"><figure class="gopher"><img src="../public/assets/images/gopher.png" alt="Go's Gopher"></figure><div class="text"><h1>Ambientes de Desenvolvimento</h1><p>Para programar em Go, voc√™ pode usar qualquer editor de texto, mas existem algumas ferramentas que facilitam muito a vida dos desenvolvedores.</p><p>Essas ferramentas ajudam a escrever c√≥digo mais r√°pido, encontrar erros e entender melhor o que est√° acontecendo no programa.</p><ul class="bullet-list"><li>Visual Studio Code: Um editor de c√≥digo muito popular com suporte a Go</li><li>GoLand: Um IDE espec√≠fico para Go, com muitas funcionalidades avan√ßadas</li><li>Vim/Emacs: Editores de texto que tamb√©m t√™m suporte a Go</li><li>Go Playground: Um site onde voc√™ pode escrever e executar c√≥digo Go diretamente no navegador</li></ul></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Ambientes de Desenvolvimento</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Ambientes de Desenvolvimento</h1><p>Os comandos e estruturas fundamentais que formam a base para construir qualquer aplica√ß√£o em Go, desde a linha de comando at√© sistemas complexos que interagem com depend√™ncias na nuvem:</p><ul class="bullet-list"><li><var>go run</var>: Compila e executa um ou mais arquivos de c√≥digo-fonte Go</li><li><var>go build</var>: Compila os pacotes e suas depend√™ncias, gerando um arquivo execut√°vel</li><li><var>go get</var>: Baixa e instala pacotes de reposit√≥rios remotos, como o GitHub</li><li><var>go fmt</var>: Formata o c√≥digo Go de acordo com as conven√ß√µes de estilo da linguagem</li><li><var>go mod</var>: Gerencia depend√™ncias e m√≥dulos em projetos Go</li></ul></div><figure class="gopher"><img src="../public/assets/images/gopher.png" alt="Go's Gopher"></figure></article></section><section class="slide headed full-code"><header><div class="logo"></div><h1>Exemplos de Programas</h1><span class="page-number">0</span></header><code>package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"os"&NewLine;&Tab;"strconv"&NewLine;)&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;if len(os.Args) &lt; 2 {&NewLine;&Tab;&Tab;fmt.Println("You must inform a rule")&NewLine;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;var rule int&NewLine;&Tab;var err error&NewLine;&NewLine;&Tab;rule, err = strconv.Atoi(os.Args[1])&NewLine;&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;if os.Args[1] == "help" {&NewLine;&Tab;&Tab;&Tab;fmt.Println(os.Args[0], "&lt;rule&gt;", "[&lt;width&gt;]")&NewLine;&Tab;&Tab;&Tab;return&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;fmt.Println("The rule must be a number")&NewLine;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if rule &lt; 0 || 255 &lt; rule {&NewLine;&Tab;&Tab;fmt.Println("You must inform a rule between 0 and 255")&NewLine;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;width := 52&NewLine;&NewLine;&Tab;if len(os.Args) &gt; 2 {&NewLine;&NewLine;&Tab;&Tab;if os.Args[2] == "max" {&NewLine;&Tab;&Tab;&Tab;width = 238&NewLine;&Tab;&Tab;} else {&NewLine;&Tab;&Tab;&Tab;width, err = strconv.Atoi(os.Args[2])&NewLine;&NewLine;&Tab;&Tab;&Tab;if err != nil {&NewLine;&Tab;&Tab;&Tab;&Tab;fmt.Println("The width must be a number")&NewLine;&Tab;&Tab;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;&Tab;if width &lt;= 0 {&NewLine;&Tab;&Tab;&Tab;&Tab;fmt.Println("The width must be a positive number")&NewLine;&Tab;&Tab;&Tab;&Tab;os.Exit(1)&NewLine;&Tab;&Tab;&Tab;}&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;fmt.Printf("Rendering rule %d\n", rule)&NewLine;&NewLine;&Tab;generation := [2][]int8{&NewLine;&Tab;&Tab;make([]int8, width),&NewLine;&Tab;&Tab;make([]int8, width),&NewLine;&Tab;}&NewLine;&NewLine;&Tab;generation[0][(width-1)/2] = 1&NewLine;&NewLine;&Tab;for y := range ((width + 3) / 2) & ^1 {&NewLine;&Tab;&Tab;top := generation[y&1][width-1]&lt;&lt;1 | generation[y&1][0]&NewLine;&NewLine;&Tab;&Tab;for x := range width - 1 {&NewLine;&Tab;&Tab;&Tab;top = top&0b011&lt;&lt;1 | generation[y&1][x+1]&NewLine;&NewLine;&Tab;&Tab;&Tab;if (rule & (1 &lt;&lt; top)) != 0 {&NewLine;&Tab;&Tab;&Tab;&Tab;generation[^y&1][x] = 1&NewLine;&Tab;&Tab;&Tab;} else {&NewLine;&Tab;&Tab;&Tab;&Tab;generation[^y&1][x] = 0&NewLine;&Tab;&Tab;&Tab;}&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;top = top&0b011&lt;&lt;1 | generation[y&1][0]&NewLine;&NewLine;&Tab;&Tab;if (rule & (1 &lt;&lt; top)) != 0 {&NewLine;&Tab;&Tab;&Tab;generation[^y&1][width-1] = 1&NewLine;&Tab;&Tab;} else {&NewLine;&Tab;&Tab;&Tab;generation[^y&1][width-1] = 0&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;if y&1 == 0 {&NewLine;&Tab;&Tab;&Tab;for x := range width {&NewLine;&Tab;&Tab;&Tab;&Tab;switch generation[0][x]&lt;&lt;1 | generation[1][x] {&NewLine;&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b00:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u0020")&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b01:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u2584")&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b10:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u2580")&NewLine;&Tab;&Tab;&Tab;&Tab;case 0b11:&NewLine;&Tab;&Tab;&Tab;&Tab;&Tab;fmt.Print("\u2588")&NewLine;&Tab;&Tab;&Tab;&Tab;}&NewLine;&Tab;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;&Tab;fmt.Println()&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;}&NewLine;</code></section><section class="slide headed playground"><header><div class="logo"></div><h1>Exemplos de Programas</h1><span class="page-number">0</span></header><article><code class="input" spellcheck="false">package main&NewLine;&NewLine;import "fmt"&NewLine;&NewLine;func main() {&NewLine;&Tab;fmt.Println("Hello, World!")&NewLine;}</code><div class="run"><input class="args" type="text"><input class="submit" type="button" value="Run"></div><code class="output"></code></article></section><section class="slide headed"><header><div class="logo"></div><h1>Coletor de Lixo</h1><span class="page-number">0</span></header><article class="image"><div class="text"><h1>Coletor de Lixo</h1><p>O garbage collector (GC) em Go √© respons√°vel por gerenciar automaticamente a mem√≥ria. Ele identifica e libera objetos que n√£o s√£o mais utilizados pelo programa, evitando vazamentos de mem√≥ria.</p></div><figure class="gc"><img class="soft" src="../public/assets/images/gc.gif" alt="Coletor de Lixo"></figure></article></section><section class="slide headed"><header><div class="logo"></div><h1>Concorr√™ncia</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Concorr√™ncia em Go</h1><p>Concorr√™ncia √© quando o programa consegue realizar v√°rias tarefas ao mesmo tempo. Imagine um restaurante com v√°rios gar√ßons atendendo clientes ao mesmo tempo, isso √© concorr√™ncia!</p><p>Em Go, usamos algo chamado goroutine para isso. Cada goroutine √© como um gar√ßom: ela faz um trabalho separado sem atrapalhar os outros.</p><p>Para os gar√ßons (goroutines) se comunicarem entre si, usamos canais. Um canal √© como um tubo por onde um manda mensagem para o outro.</p><p>O legal √© que o Go cuida disso tudo automaticamente, sem que a gente precise se preocupar com detalhes complicados.</p><p>A ideia principal do Go √©: "Em vez de brigar por acesso √† mem√≥ria, as partes do programa conversam entre si de forma organizada."</p></div><code>package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;// Simula um gar√ßom chamando n√∫meros da fila&NewLine;func chamarFila(nome string, ch chan string) {&NewLine;&NewLine;&Tab;for i := range 3 {&NewLine;&Tab;&Tab;ch &lt;- fmt.Sprintf(&NewLine;&Tab;&Tab;&Tab;"%s chamando n√∫mero %d", nome, i+1)&NewLine;&NewLine;&Tab;&Tab;// Espera 0.1 seg&NewLine;&Tab;&Tab;time.Sleep(100 * time.Millisecond)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;close(ch)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;// Cria um canal pra enviar mensagens em string&NewLine;&Tab;canal := make(chan string)&NewLine;&NewLine;&Tab;// Inicia a fun√ß√£o chamarFila em paralelo&NewLine;&Tab;go chamarFila("Alan  ", canal)&NewLine;&Tab;go chamarFila("Juan  ", canal)&NewLine;&Tab;go chamarFila("Luan  ", canal)&NewLine;&Tab;go chamarFila("Mateus", canal)&NewLine;&Tab;go chamarFila("Vitor ", canal)&NewLine;&NewLine;&Tab;// Recebe e imprime as mensagens enviadas&NewLine;&Tab;for mensagem := range canal {&NewLine;&Tab;&Tab;fmt.Println(mensagem)&NewLine;&Tab;}&NewLine;}&NewLine;</code></article></section><section class="slide headed playground"><header><div class="logo"></div><h1>Concorr√™ncia</h1><span class="page-number">0</span></header><article><div class="run"><input class="args" type="text"><input class="submit" type="button" value="Run"></div><code class="input" spellcheck="false">package main&NewLine;&NewLine;import (&NewLine;&Tab;"fmt"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;// Simula um gar√ßom chamando n√∫meros da fila&NewLine;func chamarFila(nome string, ch chan string) {&NewLine;&NewLine;&Tab;for i := range 3 {&NewLine;&Tab;&Tab;ch &lt;- fmt.Sprintf(&NewLine;&Tab;&Tab;&Tab;"%s chamando n√∫mero %d", nome, i+1)&NewLine;&NewLine;&Tab;&Tab;// Espera 0.1 seg&NewLine;&Tab;&Tab;time.Sleep(100 * time.Millisecond)&NewLine;&Tab;}&NewLine;&NewLine;&Tab;close(ch)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;// Cria um canal pra enviar mensagens em string&NewLine;&Tab;canal := make(chan string)&NewLine;&NewLine;&Tab;// Inicia a fun√ß√£o chamarFila em paralelo&NewLine;&Tab;go chamarFila("Alan  ", canal)&NewLine;&Tab;go chamarFila("Juan  ", canal)&NewLine;&Tab;go chamarFila("Luan  ", canal)&NewLine;&Tab;go chamarFila("Mateus", canal)&NewLine;&Tab;go chamarFila("Vitor ", canal)&NewLine;&NewLine;&Tab;// Recebe e imprime as mensagens enviadas&NewLine;&Tab;for mensagem := range canal {&NewLine;&Tab;&Tab;fmt.Println(mensagem)&NewLine;&Tab;}&NewLine;}&NewLine;</code><code class="output"></code></article></section><section class="slide headed playground"><header><div class="logo"></div><h1>Concorr√™ncia</h1><span class="page-number">0</span></header><article><div class="run"><input class="args" type="text"><input class="submit" type="button" value="Run"></div><code class="input" spellcheck="false">package main&NewLine;&NewLine;import (&NewLine;&Tab;"cmp"&NewLine;&Tab;"fmt"&NewLine;&Tab;"math/rand"&NewLine;&Tab;"os"&NewLine;&Tab;"strconv"&NewLine;&Tab;"sync"&NewLine;&Tab;"time"&NewLine;)&NewLine;&NewLine;const LenghtThreshold = 32&NewLine;&NewLine;func SingleThreadedQuickSort(arr []int) {&NewLine;&NewLine;&Tab;if len(arr) &lt;= LenghtThreshold {&NewLine;&Tab;&Tab;InsertionSort(arr)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;pivot := _Partition(arr)&NewLine;&NewLine;&Tab;SingleThreadedQuickSort(arr[:pivot])&NewLine;&Tab;SingleThreadedQuickSort(arr[pivot+1:])&NewLine;}&NewLine;&NewLine;func MultiThreadedQuickSort(arr []int) {&NewLine;&NewLine;&Tab;if len(arr) &lt;= LenghtThreshold {&NewLine;&Tab;&Tab;InsertionSort(arr)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;var wg sync.WaitGroup&NewLine;&NewLine;&Tab;wg.Add(1)&NewLine;&Tab;go _SyncMultiThreadedQuickSort(arr, &wg)&NewLine;&NewLine;&Tab;wg.Wait()&NewLine;}&NewLine;&NewLine;func _SyncMultiThreadedQuickSort(arr []int, wg *sync.WaitGroup) {&NewLine;&NewLine;&Tab;defer wg.Done()&NewLine;&NewLine;&Tab;if len(arr) &lt;= LenghtThreshold {&NewLine;&Tab;&Tab;InsertionSort(arr)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;pivot := _Partition(arr)&NewLine;&NewLine;&Tab;wg.Add(2)&NewLine;&Tab;go _SyncMultiThreadedQuickSort(arr[:pivot], wg)&NewLine;&Tab;go _SyncMultiThreadedQuickSort(arr[pivot+1:], wg)&NewLine;}&NewLine;&NewLine;func _Partition(arr []int) int {&NewLine;&NewLine;&Tab;pivot := arr[0]&NewLine;&Tab;i := 1&NewLine;&NewLine;&Tab;for j := 1; j &lt; len(arr); j++ {&NewLine;&Tab;&Tab;if arr[j] &lt;= pivot {&NewLine;&Tab;&Tab;&Tab;arr[i], arr[j] = arr[j], arr[i]&NewLine;&Tab;&Tab;&Tab;i++&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;arr[0], arr[i-1] = arr[i-1], arr[0]&NewLine;&Tab;return i - 1&NewLine;}&NewLine;&NewLine;func BenchMark(fn func([]int), arr []int) time.Duration {&NewLine;&Tab;start := time.Now()&NewLine;&NewLine;&Tab;fn(arr)&NewLine;&NewLine;&Tab;return time.Since(start)&NewLine;}&NewLine;&NewLine;func main() {&NewLine;&NewLine;&Tab;if len(os.Args) &lt; 2 {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"you must inform a number")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;size, err := strconv.Atoi(os.Args[1])&NewLine;&Tab;if err != nil {&NewLine;&Tab;&Tab;fmt.Println(err)&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if size &lt;= 0 {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"the informed number must be >0")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;var sarr, marr []int&NewLine;&NewLine;&Tab;{&NewLine;&Tab;&Tab;arr := make([]int, size)&NewLine;&NewLine;&Tab;&Tab;for i := range arr {&NewLine;&Tab;&Tab;&Tab;arr[i] = i + 1&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;for i := range len(arr) {&NewLine;&Tab;&Tab;&Tab;s := rand.Intn(size)&NewLine;&Tab;&Tab;&Tab;arr[i], arr[s] = arr[s], arr[i]&NewLine;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;sarr = make([]int, len(arr))&NewLine;&Tab;&Tab;copy(sarr, arr)&NewLine;&Tab;&Tab;marr = arr&NewLine;&Tab;}&NewLine;&NewLine;&Tab;mtt := BenchMark(MultiThreadedQuickSort, marr)&NewLine;&Tab;stt := BenchMark(SingleThreadedQuickSort, sarr)&NewLine;&NewLine;&Tab;if !_VerifySortion(sarr) {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"the singletheaded array wasn't sorted correctly")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;if !_VerifySortion(marr) {&NewLine;&Tab;&Tab;fmt.Println(&NewLine;&Tab;&Tab;&Tab;"the multitheaded array wasn't sorted correctly")&NewLine;&Tab;&Tab;return&NewLine;&Tab;}&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Singlethreaded: %dŒºs\n",&NewLine;&Tab;&Tab;stt.Microseconds())&NewLine;&NewLine;&Tab;fmt.Printf(&NewLine;&Tab;&Tab;"Multithreaded: %dŒºs\n",&NewLine;&Tab;&Tab;mtt.Microseconds())&NewLine;}&NewLine;&NewLine;func _VerifySortion[T cmp.Ordered](arr []T) bool {&NewLine;&NewLine;&Tab;for i := 1; i &lt; len(arr); i++ {&NewLine;&Tab;&Tab;if arr[i-1] > arr[i] {&NewLine;&Tab;&Tab;&Tab;return false&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;&NewLine;&Tab;return true&NewLine;}&NewLine;&NewLine;func InsertionSort(arr []int) {&NewLine;&Tab;for i := 1; i &lt; len(arr); i++ {&NewLine;&NewLine;&Tab;&Tab;for tmp, j := arr[i], i; ; j-- {&NewLine;&NewLine;&Tab;&Tab;&Tab;if j &lt;= 0 || arr[j-1] &lt;= tmp {&NewLine;&Tab;&Tab;&Tab;&Tab;arr[j] = tmp&NewLine;&Tab;&Tab;&Tab;&Tab;break&NewLine;&Tab;&Tab;&Tab;}&NewLine;&NewLine;&Tab;&Tab;&Tab;arr[j] = arr[j-1]&NewLine;&Tab;&Tab;}&NewLine;&Tab;}&NewLine;}</code><code class="output"></code></article></section><section class="slide headed"><header><div class="logo"></div><h1>Vantagens e Desvantagens</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Vantagens</h1><ul class="bullet-list"><li>Desempenho: compila√ß√£o r√°pida</li><li>Simplicidade: sintaxe clara e f√°cil de aprender</li><li>Concorr√™ncia Nativa: suporte robusto para concorr√™ncia</li><li>Portabilidade: c√≥digo em Go pode ser executado em diferentes arquiteturas e sistemas operacionais</li><li>Curva de Aprendizado: f√°cil de aprender para iniciantes</li></ul></div><div class="text"><h1>Desvantagens</h1><ul class="bullet-list"><li>Falta de Recursos Avan√ßados: n√£o possui recursos como heran√ßa, operador tern√°rio e sobrecarga de func√µes</li><li>Bibliotecas Limitadas: ecossistema ainda em crescimento</li><li>Coletor de lixo: torna o gerenciamento de mem√≥ria menos eficiente</li><li>Curva de Aprendizado: Pode ser dif√≠cil para iniciantes devido √† concorr√™ncia e gerenciamento de mem√≥ria</li></ul></div></article></section><section class="slide headed"><header><div class="logo"></div><h1>Conclus√£o</h1><span class="page-number">0</span></header><article class="general"><div class="text"><h1>Conclus√£o</h1><p>Ao adentrarmos nossa jornada pela linguagem Go, fica claro que nao estamos falando apenas de mais uma ferramenta no vasto universo da programa√ß√£o. Go nasceu de uma necessidade real, de uma frustra√ß√£o de seus criadores com as ferramentas existentes, e sua solu√ß√£o foi pr√°tica: simplicidade aliada √° performance.</p><p>Go nos ensina uma li√ß√£o valiosa, na complexidade de software modernos, as vezes a solu√ß√£o mais sofisticada √© uma mais simples.</p></div><code>package main&NewLine;&NewLine;import "fmt"&NewLine;&NewLine;func main() {&NewLine;&Tab;fmt.Println("Bye, World! üëãüòÅ")&NewLine;}&NewLine;</code></article></section><section class="slide final">Fim da apresenta√ß√£o</section><footer><progress class="progress"></progress></footer></body></html>